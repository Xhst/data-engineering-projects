import pandas as pd
from bs4 import BeautifulSoup
import os
from groq import Groq
import json
import paths
from dotenv import load_dotenv
from pathlib import Path
from io import StringIO
from tabulate import tabulate

load_dotenv(dotenv_path=Path('../.env'))

def clean_table(html_table: str) -> str:
    """
    Function to clean an HTML table, removing all attributes and tags that are not part of the table structure.

    Args:
        html_table (str): The HTML table to clean.

    Returns:
        str: The cleaned HTML table.
    """
    soup = BeautifulSoup(html_table, "html.parser")

    # Tags that are part of the table structure and should be kept
    table_tags = ['table', 'tr', 'td', 'th', 'tbody', 'thead', 'tfoot']

    tags_to_remove = ['annotation', 'annotation-xml']

    for tag in soup.find_all(True):  
        # Remove id and class attributes
        if tag.attrs and 'id' in tag.attrs:
            del tag.attrs['id']
        if tag.attrs and 'class' in tag.attrs:
            del tag.attrs['class']

        # Remove tags that are not part of the table structure including their content
        if tag.name in tags_to_remove:
            tag.decompose()
            continue
        
        # Remove all tags that are not part of the table structure and keep their content
        if tag.name not in table_tags:
            try:
                tag.unwrap()
            except ValueError:
                tag.decompose()

    
    return soup.prettify()


def parse_html_table(html_table: str):
    html_buffer = StringIO(html_table)
    df = pd.read_html(html_buffer)[0].fillna('')
    df_list = df.values.tolist()

    return tabulate(df_list)


if __name__ == "__main__":
    with open(paths.RAW + '/2303.00491.json', 'r') as file:
        data = json.load(file)
        table_data = data['S3.T1']
    
    html_content = clean_table(table_data['table'])
    
    parsed_table = parse_html_table(html_content)

    print(parsed_table)

    example_table = """
    ----------  -------------  -------------  -------------  -------------  -------------  -------------
                Lively         Lively         Harsh          Harsh          Wellcoming     Wellcoming
    Model       SI-MOS         N-MOS          SI-MOS         N-MOS          SI-MOS         N-MOS
    GT          4.49  ±  0.14  4.28  ±  0.38  4.52  ±  0.14  4.85  ±  0.21  4.01  ±  0.26  4.28  ±  0.29
    Synth none  2.67  ±  0.26  1.74  ±  0.24  2.71  ±  0.14  2.20  ±  0.22  2.63  ±  0.17  2.33  ±  0.27
    Synth TTS   2.65  ±  0.15  2.55  ±  0.16  2.17  ±  0.15  2.11  ±  0.19  2.99  ±  0.14  2.55  ±  0.27
    Synth both  2.24  ±  0.14  2.90  ±  0.31  2.25  ±  0.15  2.28  ±  0.20  3.06  ±  0.17  3.44  ±  0.28
    VC          3.04  ±  0.16  3.66  ±  0.26  1.93  ±  0.29  3.66  ±  0.38  3.61  ±  0.19  3.95  ±  0.54
    ----------  -------------  -------------  -------------  -------------  -------------  -------------
    """
    example_caption = "Table 3: Style Intensity (SI-MOS) and Naturalness (N-MOS) Mean Opinion Scores with 95% confidence intervals."
    example_reference = """
    The results indicate that synthetic data generated by voice conversion (VC) exhibit higher naturalness than those from cross-speaker style transfer experiments.
    Consequently, both the Synth TTS and Synth both experiments, which incorporate synthetic data during training, show increased naturalness compared to Synth None, with Synth both demonstrating the highest improvement.
    However, we note that for style intensity, the Synth none configuration performed better in two out of three expressive styles in the dataset, despite having lower naturalness in each case (Table 3).
    """
    example_response = """
    { "Model": "GT", "Speaker-Style": "Lively", "SI-MOS": "4.49 ± 0.14", "N-MOS": "4.28 ± 0.38" },
    { "Model": "GT", "Speaker-Style": "Harsh", "SI-MOS": "4.52 ± 0.14", "N-MOS": "4.85 ± 0.21" },
    { "Model": "GT", "Speaker-Style": "Wellcoming", "SI-MOS": "4.01 ± 0.26", "N-MOS": "4.28 ± 0.29" },
    { "Model": "Synth none", "Speaker-Style": "Lively", "SI-MOS": "2.67 ± 0.26", "N-MOS": "1.74 ± 0.24" },
    { "Model": "Synth none", "Speaker-Style": "Harsh", "SI-MOS": "2.71 ± 0.14", "N-MOS": "2.20 ± 0.22" },
    { "Model": "Synth none", "Speaker-Style": "Wellcoming", "SI-MOS": "2.63 ± 0.17", "N-MOS": "2.33 ± 0.27" },
    { "Model": "Synth TTS", "Speaker-Style": "Lively", "SI-MOS": "2.65 ± 0.15", "N-MOS": "2.55 ± 0.16" },
    { "Model": "Synth TTS", "Speaker-Style": "Harsh", "SI-MOS": "2.17 ± 0.15", "N-MOS": "2.11 ± 0.19" },
    { "Model": "Synth TTS", "Speaker-Style": "Wellcoming", "SI-MOS": "2.99 ± 0.14", "N-MOS": "2.55 ± 0.27" },
    { "Model": "Synth both", "Speaker-Style": "Lively", "SI-MOS": "2.24 ± 0.14", "N-MOS": "2.90 ± 0.31" },
    { "Model": "Synth both", "Speaker-Style": "Harsh", "SI-MOS": "2.25 ± 0.15", "N-MOS": "2.28 ± 0.20" },
    { "Model": "Synth both", "Speaker-Style": "Wellcoming", "SI-MOS": "3.06 ± 0.17", "N-MOS": "3.44 ± 0.28" },
    { "Model": "Voice Conversion (VC)", "Speaker-Style": "Lively", "SI-MOS": "3.04 ± 0.16", "N-MOS": "3.66 ± 0.26" },
    { "Model": "Voice Conversion (VC)", "Speaker-Style": "Harsh", "SI-MOS": "1.93 ± 0.29", "N-MOS": "3.66 ± 0.38" },
    { "Model": "Voice Conversion (VC)", "Speaker-Style": "Wellcoming", "SI-MOS": "3.61 ± 0.19", "N-MOS": "3.95 ± 0.54" }
    """

    content = """
    I want to extract specifications from tables in a research paper. Here is an example of a table, caption, and reference.
    Table:
    {example_table}
    Caption:
    {example_caption}
    Reference:
    {example_reference}
    Response:
    {example_response}

    Now extract specifications from the table below.
    Table:
    {table} 
    Caption:
    {caption}
    Reference:
    {reference}

    Response should only include the specifications from the table.
    """.format(
        example_table=example_table,
        example_caption=example_caption,
        example_reference=example_reference,
        example_response=example_response,
        table=parsed_table, 
        caption=table_data['caption'],
        reference=table_data['references'][0]
    )

    client = Groq(
        api_key=os.environ.get("GROQ_API_KEY"),
    )

    chat_completion = client.chat.completions.create(
        messages=[
            {
                "role": "system",
                "content": "You are an expert in computer science and in understanding tables.",
            },
            {
                "role": "user",
                "content": content,
            }
        ],
        model="llama-3.3-70b-versatile",

        # Controls randomness: lowering results in less random completions.
        # As the temperature approaches zero, the model will become deterministic and repetitive.
        temperature=0.5,
    )

    print(chat_completion.choices[0].message.content)